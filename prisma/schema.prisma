// Nafarrock - Prisma Schema
// Guía del rock en Navarra | PostgreSQL
// Diseñado para escalabilidad y normalización

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTENTICACIÓN Y USUARIOS
// ============================================

enum UserRole {
  ADMIN      // Moderación, aprobación, CRUD total
  BANDA      // Registro de banda: editar perfil propio, crear contenido
  PROMOTOR   // Crear y gestionar eventos
  USUARIO    // Usuario registrado sin rol especial
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String?   // Hash bcrypt para login email
  emailVerified DateTime?
  name          String?
  image         String?
  role          UserRole  @default(USUARIO)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts        Account[]
  sessions        Session[]
  bandProfile     Band?     // Si es rol BANDA
  promoterProfile Promoter? // Si es rol PROMOTOR

  @@index([email])
  @@index([role])
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// BANDAS
// ============================================

model Band {
  id          String   @id @default(cuid())
  slug        String   @unique // URL amigable
  name        String
  bio         String?  @db.Text
  genres      String[] // ["punk", "rock urbano", "grunge"]
  location    String?  // Localidad principal
  isActive    Boolean  @default(true) // Activa/inactiva
  isEmerging  Boolean  @default(false) // Destacar bandas emergentes
  imageUrl    String?  // Cloudinary
  logoUrl     String?
  // Enlaces externos
  spotifyUrl  String?
  bandcampUrl String?
  instagramUrl String?
  facebookUrl String?
  youtubeUrl  String?
  webUrl      String?
  // Aprobación (anti-spam)
  approved    Boolean  @default(false)
  approvedAt  DateTime?
  approvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId  String  @unique // Usuario propietario
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  events  BandEvent[]

  @@index([slug])
  @@index([isActive])
  @@index([isEmerging])
  @@index([approved])
  @@index([genres])
  @@index([location])
  @@map("bands")
}

// ============================================
// SALAS Y ESPACIOS
// ============================================

model Venue {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?  @db.Text
  address     String?
  city        String   // Localidad en Navarra
  imageUrl    String?
  capacity    Int?
  websiteUrl  String?
  mapUrl      String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  events Event[]

  @@index([slug])
  @@index([city])
  @@index([isActive])
  @@map("venues")
}

// ============================================
// EVENTOS Y FESTIVALES
// ============================================

model Event {
  id          String    @id @default(cuid())
  slug        String    @unique
  title       String
  description String?   @db.Text
  type        EventType // CONCIERTO | FESTIVAL
  date        DateTime
  endDate     DateTime? // Para festivales multi-día
  doorsOpen   String?   // "20:00"
  imageUrl    String?
  ticketUrl   String?
  price       String?   // "Entrada libre" | "15€"
  isApproved  Boolean   @default(false)
  approvedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  venueId     String
  venue       Venue     @relation(fields: [venueId], references: [id], onDelete: Restrict)
  promoterId  String?
  promoter    Promoter? @relation(fields: [promoterId], references: [id], onDelete: SetNull)
  bands       BandEvent[]

  @@index([slug])
  @@index([date])
  @@index([type])
  @@index([venueId])
  @@index([isApproved])
  @@map("events")
}

enum EventType {
  CONCIERTO
  FESTIVAL
}

// Relación many-to-many: Bandas en eventos
model BandEvent {
  id        String   @id @default(cuid())
  eventId   String
  bandId    String
  order     Int      @default(0) // Orden de actuación
  isHeadliner Boolean @default(false)
  createdAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  band  Band  @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@unique([eventId, bandId])
  @@index([eventId])
  @@index([bandId])
  @@map("band_events")
}

// Promotores (gestionan eventos)
model Promoter {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  websiteUrl  String?
  contactEmail String?
  imageUrl    String?
  approved    Boolean  @default(false)
  approvedAt  DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId  String  @unique
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  events  Event[]

  @@index([approved])
  @@map("promoters")
}
