// Nafarrock - Prisma Schema
// Guía del rock en Nafarroa | PostgreSQL
// Diseñado para escalabilidad y normalización

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// AUTENTICACIÓN Y USUARIOS
// ============================================

enum UserRole {
  ADMIN       // Moderación, aprobación, CRUD total
  BANDA       // Registro de banda
  SALA        // Registro de sala/espacio
  FESTIVAL    // Organizador de festival
  ORGANIZADOR // Organizador de eventos
  PROMOTOR    // Crear y gestionar eventos
  USUARIO     // Usuario registrado sin rol especial
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String?   // Hash bcrypt para login email
  emailVerified DateTime?
  name          String?   // Nombre completo (legacy)
  firstName     String?   // Nombre personal
  lastName      String?   // Apellidos
  phone         String?   // Solo visible para admin
  image         String?
  role          UserRole  @default(USUARIO)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts         Account[]
  sessions         Session[]
  bandProfile      Band?      // Si es rol BANDA
  promoterProfile  Promoter?   // Si es rol PROMOTOR
  venueProfile     Venue?      // Si es rol SALA
  organizerProfile Organizer? // Si es rol ORGANIZADOR
  festivalProfile  Festival?   // Si es rol FESTIVAL
  eventsCreated    Event[]    @relation("EventCreator")
  profileClaims    ProfileClaim[]

  @@index([email])
  @@index([role])
  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token     String? @db.Text
  expires_at       Int?
  token_type       String?
  scope            String?
  id_token         String? @db.Text
  session_state    String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// BANDAS
// ============================================

model Band {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  bio         String?  @db.Text
  genres      String[] // ["punk", "rock urbano", "grunge"]
  location    String?
  foundedYear Int?
  isActive    Boolean  @default(true)
  isEmerging  Boolean  @default(false)
  imageUrl    String?  // Imagen principal
  logoUrl     String?
  images      String[] // Max 3 imágenes en Cloudinary
  // Enlaces externos
  spotifyUrl   String?
  bandcampUrl  String?
  instagramUrl String?
  facebookUrl  String?
  youtubeUrl   String?
  webUrl       String?
  // Aprobación
  approved    Boolean  @default(false)
  approvedAt  DateTime?
  approvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  // Perfil híbrido: creado por Nafarrock sin propietario hasta reclamación
  createdByNafarrock Boolean @default(false)
  userId  String? @unique // null si admin creó la banda o pendiente de reclamación
  user    User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  events  BandEvent[]
  claimRequests ProfileClaim[]
  members BandMember[]

  @@index([slug])
  @@index([isActive])
  @@index([isEmerging])
  @@index([approved])
  @@index([genres])
  @@index([location])
  @@map("bands")
}

// Miembros de banda (nombre + instrumento)
model BandMember {
  id         String @id @default(cuid())
  name       String
  instrument String
  order      Int    @default(0)

  bandId String
  band   Band   @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@index([bandId])
  @@map("band_members")
}

// ============================================
// SALAS Y ESPACIOS
// ============================================

model Venue {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?  @db.Text
  address     String?
  city        String
  foundedYear Int?
  imageUrl    String?
  logoUrl     String?
  images      String[] // Max 3
  capacity    Int?
  websiteUrl  String?
  mapUrl      String?
  instagramUrl String?
  facebookUrl  String?
  isActive    Boolean  @default(true)
  // Aprobación (cuando creado por usuario)
  approved    Boolean  @default(true) // true si admin lo creó, false si usuario pendiente
  approvedAt  DateTime?
  approvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdByNafarrock Boolean @default(false)
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id], onDelete: SetNull)
  events Event[]
  claimRequests ProfileClaim[]

  @@index([slug])
  @@index([city])
  @@index([isActive])
  @@index([approved])
  @@map("venues")
}

// ============================================
// FESTIVALES (organizaciones)
// ============================================

model Festival {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?  @db.Text
  location    String?
  foundedYear Int?
  logoUrl     String?
  images      String[]
  websiteUrl  String?
  instagramUrl String?
  facebookUrl  String?
  approved    Boolean  @default(false)
  approvedAt  DateTime?
  approvedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdByNafarrock Boolean @default(false)
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)
  events Event[] @relation("FestivalEvents")
  claimRequests ProfileClaim[]

  @@index([slug])
  @@index([approved])
  @@map("festivals")
}

// ============================================
// ORGANIZADORES DE EVENTOS
// ============================================

model Organizer {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?  @db.Text
  logoUrl     String?
  websiteUrl  String?
  contactEmail String?
  approved    Boolean  @default(false)
  approvedAt  DateTime?
  // Plan PRO (preparado, inactivo)
  isPro       Boolean  @default(false)
  planType    String?  // PRO, PRO_PLUS, etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId String  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  events Event[] @relation("OrganizerEvents")

  @@index([approved])
  @@index([isPro])
  @@map("organizers")
}

// ============================================
// EVENTOS Y FESTIVALES
// ============================================

model Event {
  id               String    @id @default(cuid())
  slug             String    @unique
  title            String
  description      String?   @db.Text
  type             EventType
  date             DateTime
  endDate          DateTime?
  doorsOpen        String?
  imageUrl         String?   // Cartel principal
  images           String[]  // Imágenes adicionales del cartel
  ticketUrl        String?
  price            String?
  abonos           String?   // Info de abonos
  instagramUrl     String?   // Enlace Instagram (publicación, perfil)
  facebookUrl      String?   // Enlace Facebook (evento, página)
  twitterUrl       String?   // Enlace X/Twitter
  webUrl           String?   // Web del evento
  capacity         Int?      // Aforo del evento
  isSoldOut        Boolean   @default(false)  // Sin entradas (SALA, FESTIVAL, ORGANIZADOR, PROMOTOR)
  isApproved       Boolean   @default(false)
  approvedAt       DateTime?
  createdByNafarrock Boolean @default(false)
  // Límite 1 evento cada 5 días - admin puede eximir
  eventLimitExempt Boolean   @default(false)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  venueId          String
  venue            Venue     @relation(fields: [venueId], references: [id], onDelete: Restrict)
  promoterId       String?
  promoter         Promoter? @relation(fields: [promoterId], references: [id], onDelete: SetNull)
  organizerId      String?
  organizer        Organizer? @relation("OrganizerEvents", fields: [organizerId], references: [id], onDelete: SetNull)
  festivalId       String?
  festival         Festival? @relation("FestivalEvents", fields: [festivalId], references: [id], onDelete: SetNull)
  createdByUserId  String?
  createdByUser     User?     @relation("EventCreator", fields: [createdByUserId], references: [id], onDelete: SetNull)
  bands             BandEvent[]

  @@index([slug])
  @@index([date])
  @@index([type])
  @@index([venueId])
  @@index([isApproved])
  @@index([createdByUserId])
  @@map("events")
}

enum EventType {
  CONCIERTO
  FESTIVAL
}

model BandEvent {
  id         String   @id @default(cuid())
  eventId    String
  bandId     String
  order      Int      @default(0)
  isHeadliner Boolean @default(false)
  createdAt  DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  band  Band  @relation(fields: [bandId], references: [id], onDelete: Cascade)

  @@unique([eventId, bandId])
  @@index([eventId])
  @@index([bandId])
  @@map("band_events")
}

// Promotores
model Promoter {
  id           String   @id @default(cuid())
  slug         String   @unique
  name         String
  description  String?  @db.Text
  websiteUrl   String?
  contactEmail String?
  imageUrl     String?
  approved     Boolean  @default(false)
  approvedAt   DateTime?
  // Plan PRO (preparado, inactivo)
  isPro        Boolean  @default(false)
  planType     String?  // PRO, PRO_PLUS, etc.
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  userId String  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  events Event[]

  @@index([approved])
  @@index([slug])
  @@index([isPro])
  @@map("promoters")
}

// ============================================
// SOLICITUDES DE RECLAMACIÓN DE PERFILES
// ============================================

enum ClaimStatus {
  PENDING_CLAIM
  APPROVED
  REJECTED
}

enum ClaimEntityType {
  BAND
  VENUE
  FESTIVAL
}

model ProfileClaim {
  id        String       @id @default(cuid())
  userId    String
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  entityType ClaimEntityType
  entityId  String
  status    ClaimStatus  @default(PENDING_CLAIM)
  message   String?      @db.Text
  processedAt DateTime?
  processedBy String?
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  bandId    String?
  band      Band?       @relation(fields: [bandId], references: [id], onDelete: Cascade)
  venueId   String?
  venue     Venue?      @relation(fields: [venueId], references: [id], onDelete: Cascade)
  festivalId String?
  festival  Festival?   @relation(fields: [festivalId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([entityType])
  @@index([bandId])
  @@index([venueId])
  @@index([festivalId])
  @@map("profile_claims")
}
